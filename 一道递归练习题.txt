题目：
一个标准的科学实验是，抛球并且看它能够弹跳多高。一旦球的“弹跳性”已经确定了，这个比率值就会给出弹跳性的指数。
例如，如果球从10米高落下弹跳到6米高，这个索引就是0.6，并且球在一次弹跳之后总的运动距离是16米。
如果球继续弹跳，两次弹跳后的距离将会是10米+6米+6米+3.6米=25.6米。
注意，每次后续的弹跳运动的距离，都是到地板的距离加上这个距离的0.6倍，这个0.6倍就是球反弹回来的距离。
编一个程序，让用户输入球的一个初始高度以及允许球持续弹跳的次数。输出球的运动的总距离。

刚开始想复杂了,原题目的意思是,从某高度下落并且又弹起一定高度算一次,我理解成不算第一次从最高处落下,之后每次弹起落下算一次,所以比原题复杂,给出两种代码

原题:
---------------------------------
递归解法
t = 0

def f1(h, n, r=0.6):
    global t
    if n == 1:
        t = h * r
        return h + h * r
    n -= 1
    return h + f1(h * r, n)


def output(h, n, r=0.6):
    return 2 * f1(h, n, r) - h - t
---------------------------------
常规解法
def f2(h, n, r=0.6):
    sum = 0
    for i in range(n):
        t = h * (r ** i)
        sum += (t + t * r)
    return sum





我把题目改编后的解法
---------------------------------
递归解法
def recursion(h, n, r):
    if n == 0:
        return h
    if n == 1:
        return h + h * r / 2
    n -= 2
    return h + recursion(h * r, n, r)


def recursion_output(h, n, r=0.6):
    return 2 * recursion(h, n, r) - h
---------------------------------
常规解法
def normal(h, n, r=0.6):
    t = n // 2
    sum = h
    for i in range(t):
        n -= 2
        sum += 2 * h * (r ** (i + 1))
        if n == 0:
            return sum
        if n == 1:
            return (sum + h * (r ** (i + 2)))

